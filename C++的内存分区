一、引言：为什么要关心内存分区？
    C++相比Java和Python这类语言，其最大特点就是给开发者更高的权限，即你可以理解为"上限"更高，
指针概念的出现使其拥有了操控系统内存的权利，这是其他编程语言很难办到的，因为C++不像Python和Java那样设计出来就是为了开发应用，
它显得不那么"商业化"，这也使其学习成本与开发成本相比其他语言更高，其令开发者们最头疼的一点便是内存控制，很多时候你需要自己申请
与释放内存，这也是许多初学者乃至程序员最容易出错的点，同时它也是所有开发者无法避开的话题，指针悬空，越界访问，使用未初始化内存，
重复释放等等问题常常令各位焦头烂额，但看完本篇文章后，大家一定会对内存有一个全新理解，并在以后的开发中大大减少这方面的问题

二、程序从磁盘到内存：
  首先我们来了解一下我们所写程序在内存中的分布吧
+------------------------+
|        内核空间        |
+------------------------+
|        栈（Stack）     |  向下增长
+------------------------+
|        堆（Heap）      |  向上增长
+------------------------+
| .bss 段（未初始化全局）|
+------------------------+
| .data 段（已初始化全局)|
+------------------------+
| .text 段（代码段）     |
+------------------------+
  是的，我们平时所写的代码就是存放在这5个部分里（本文暂不讨论内核空间，我们程序员也不必关心）,不同操作系统/编译器可能有差别，但基本
概念相似

三、各个内存分区的概念与特点
    1.代码段：这一部分主要是存放机器指令的，像我们平时定义的
void func()
{
  ...
}
等各类函数，他们在编译后会形成机器指令并存放在代码段中，它通常是只读的，不可被修改，同时它也是共享的，方便被多个进程访问的同时还节省了
内存空间
    2.全局/静态存储区：即上图中.bss 段与.data 段，这一部分主要是存放我们所定义的全局变量与全局/局部静态变量，诸如static int b;这种位于
未初始化全局区(.bss 段)，像static int b=0;这种，自然而然就是已初始化全局区了，在这里要注意一点，我们平时所定义的静态函数还是属于代码段，
并不属于静态区，这些变量的生命周期并不随局部函数的销毁而释放，它的生命周期贯穿程序的开始与结束，所以我们在平时开发中要尽量少用全局变量
(至于为什么不是我们这篇文章所讨论的范畴，它与编程的规范性与可维护性更相关)
    3.栈区：平时我们所定义的各种局部变量，函数参数，诸如int a=0;都存在栈中,同时，我们在函数体内定义的变量也都存在栈上，
这些变量存储位置之间是有体系的，因而编译器就需要创建"栈帧"去管理这些变量,像我们下面写的这个函数
void foo() {
    int a = 10;      // 栈上
    int b[1000];     // 栈上
} // 函数返回后，a 和 b 的内存被回收
在调用foo函数时编译器会在内存上创建栈帧，每次新建一个局部变量都是一次压栈操作，像这个int a = 10;int b[1000];都是在栈上叠加的，
当foo()函数生命周期结束后，所创建的foo函数栈帧便会自动销毁，内存又会还给操作系统，之后调用的函数会覆盖掉原先调用foo()所创建的栈帧，
也就是说它内存是连续的，我们的main函数也是如此，再加上是由编译器直接管理，其分配内存效率十分高，但其空间有限，如上图，假设栈一直向下增长，
便很可能造成栈溢出，常见场景就是函数递归
    4.堆区:这部分内存主要由我们程序员自己支配，它里面存放的主要是我们自己new/delete 或 malloc/free 出来的内存，
也就是说它不由操作系统管理，而由我们自己管理，所以它就很容易产生我上文所说的内存泄漏、悬空指针、重复释放等等问题，要解决这类问题，
最主要的就是要求我们平时养成良好的编码习惯，在实际开发代码量比较小时记得及时释放资源，当代码量巨大时根据开发需求应用RAII进行封装，
像使用vector这种动态数组分配内存就是种十分不错的选择，或者使用智能指针(如unique_ptr,shared_ptr等)，但请记住，
像我们平时用的最多的shared_ptr它也是有引用计数作为空间代价的，还有unique_ptr禁止拷贝，以及auto_ptr在转移对象时会将原指针置空，请按需使用
    5.常量区：这部分内存主要存放的是字符串字面量，比如我们定义的string s="abcde"中的abcde就存在常量区，这时候你可能要发问了，
那我int a=0;这个0存在哪呢？实际上它不存在任何区域，它被嵌入到了机器指令中，通常是存在寄存器中，编译器在汇编时会自动使用，
这种数我们称为"立即数"，这个=也是同理，当然你可能还有疑问，像int&& a=0;这种右值引用，这里的a是常量吗？答案并不是，它本质是一个a变量，
但它具有绑定到右值的常性

五、典型问题与内存分区的关系
1.栈溢出:
  我们来看一组典型的递归程序
void f() {
    int a[1000000]; // 栈空间可能不够，导致栈溢出
    f();            // 无终止条件，递归导致栈溢出
}
    当你看到这里，你一定意识到了这种没有终止条件的递归是百分百会出现栈溢出的情况的，程序会直接崩溃，通常栈在内存里只占几MB，
这时聪明的你肯定会想到，要少用递归，是的，实际开发中也是如此，递归层数过多会导致代码膨胀，
同时多次不断调用自身创立栈帧还有释放栈帧会影响程序运行效率，我们应尽量多使用循环来代替递归，在这个程序里还存在一个致命问题，
就是在栈空间上创建这种"巨量"数组，请记住，你应该在堆上去申请，即int* a=new [1000000],堆的内存是很大的，一般都有几个G，不必畏惧，
或者直接使用vector<int> a(1000000)去直接创建，效果也会更好
2.悬空指针 / 野指针：
  下面我们来看一个典型栈上的例子
int* foo() {
    int a = 10;
    return &a; // 错误：返回局部变量地址
}
这里a变量是局部变量，它随着栈帧的销毁而销毁，也就是说出了这个函数的作用域返回调用它的地方时，这个a的地址将会毫无意义，即"野指针"，
当你再使用它时，这是十分危险的，可能什么都不发生，也可能访问修改了其他资源，也可能访问到了其他内存区直接引发崩溃，这类行为被称为"未定义行为"
  我们再来看一组堆上的例子
int* p = new int(10);
delete p;
*p = 5; // 未定义行为
这里你已经将p所指向的资源释放了，你也本质失去了对这块内存的管理权，这块内存可能被其他变量所立即占用，但后来又重新对其重新解引用赋值，
这很可能会破坏堆结构，从现象上来看，这本身就不合理，你既然把它释放了，又想重新得到它，就像你捐款了，但是又想把钱重新要回来一样，
这种行为同样称为"未定义行为"
3.内存泄漏
  这类行为是我们开发中遇到过最常见的问题，new/malloc 申请但忘记 delete/free，有些开发经验欠缺的人可能觉得没什么，
反正程序结束之后所有资源都会还给操作系统嘛，没多大事吧，有这种想法的人只能说比较单纯，就拿服务器来说你应该就懂了，服务器基本上是不停的，
要是你一个地方出现内存泄漏，并且经常调用的话，堆区资源就会越来越多，服务器就会越来越卡，最后服务器就会崩，早期安卓操作系统就是由于内存泄漏
导致越用越卡，但当你重启一遍就会发现神奇的好了，写这些商业化提供给用户的业务中，处理内存泄漏是必要的，否则就很可能带来巨量经济损失
  要处理这泄露问题，开发时需要注意申请了内存不用的时候要及时还给操作系统，在必要时使用智能指针或RAII思想来对内存进行自动化管理，
我上文也都提到过了，这里就不多做赘述了
  对于测试来说，也可以使用各种内存泄漏排查软件，如Address Sanitizer，Valgrind等等

七、总结
  本文主要分析了我们平时写的代码在内存中是如何布局的，同时对于常见的一些内存报错给出了诸多原因与解决方案，在我们了解底层之后，
可以想一想如何让自己"可控"的地方提升程序运行效率呢，比如有时碎片化的申请内存，我们可不可以一次性申请"一把"内存，来减少系统调用成本呢？
这就是所谓的"池化技术"，在这里叫"内存池",同时我们也可以适当了解计算机是如何快速高效的读取数据的，如内存对齐等
