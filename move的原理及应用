一、引言
  在很多时候，我们都需要用一个即将消亡的对象去构造一个新对象，在C++11之前，我们需要对这个对象进行一次拷贝，完了之后还要对该对象进行析构，对于一些数据量小的对象可能还好，但是如果在一些需要频繁构造或者在一次性构造大规模的对象时，其性能问题是十分突出的，其中包括调用成本和空间成本等等，这时就能想到让新对象直接接管将亡对象的资源，从而避免了拷贝，也就是说直接拷贝指针，然后将原对象释放并置空即可，这样就避免了一次昂贵的拷贝构造，当然这种做法在C++11之前也是可以实现的，但其可读性十分差，例如string s1(s2);你无法区分它到底是要拷贝构造+运算符赋值还是内存接管，只能靠约定，为了更直观准确的实现这一语法，C++11特意推出了move函数

二、值类别回顾
  1.左值与右值
    左值：必须命名，可以取地址
    右值：没有名字，将亡值/临时对象，常量，不能被取地址
  左值和右值最大的区别就在于能不能取地址，右值是无法被显示定义出来的，要么就对左值一定的进行操作之后的结果为右值，要么就单纯是1,2,3,4,5这样的常量
  2.右值引用
    int&& x = 10;
    所谓左值引用是左值的别名，那么右值引用就自然而然是右值的别名了，注意：x在此处是一个左值，但其在这里表示的是右值的别名，当然这行代码在实际开发中并无任何意义，我们也不会去写，只是让大家复习一下

三、什么是 std::move？    
  1.表面含义 vs 实际含义
    很多人从字面上理解，move，移动嘛，就是直接移动原对象到要新对象上嘛，但当你思考发现，要怎么移动呢，原理是什么，式子怎么写呢，你就会发现，实际上不是这样的
    它只做了一件事，将左值对象强制变为右值，如:
    string s;
    std::move(s);//等价于static_cast<string&&>(s);
    这里的move(s)后的临时对象就是右值，请注意，它不会改变s本身的属性，其仍是左值
  2.std::move 的定义（简化）
    template <typename T>
    constexpr typename std::remove_reference<T>::type&&
    move(T&& t) noexcept;
    它底层实际上就仅仅是将其转化为右值然后返回

四、移动语义的底层原理
  1. 拷贝构造 vs 移动构造
    class Buffer {
public:
    Buffer(const Buffer& other);      // 拷贝构造
    Buffer(Buffer&& other) noexcept;  // 移动构造
};
    拷贝构造是将原对象以左值引用的形式传进去的，然后拷贝一个一模一样的对象进行返回，这样就有一次拷贝的消耗
    移动构造是将原对象以右值引用的形式传进去的，然后将资源所有权转移给新对象(即拷贝原对象资源的指针),然后将原对象置空(保证了新对象资源的安全性)，这样将拷贝资源的代价转化为了拷贝指针的代价
  2. 一个最小可运行示例
class MyString {
    char* data;
public:
    MyString(MyString&& other) noexcept {
        data = other.data;
        other.data = nullptr;
    }
};
    在这里你需要注意的一点是，原对象资源只是被"偷走了",但其本身还是可以被继续操作的，只是与实际业务的其他资源/变量没有关联了，也就是说原对象也就失去了实际意义

五、std::move 的典型使用场景
  1. 函数返回值优化
    std::vector<int> foo() 
    {
      std::vector<int> v = {1, 2, 3};
      return v; 
    }
    这里你可能会认为会返回v对象的拷贝，实际上编译器对其做了优化，实际上返回的是move(v),然后调用移动构造绑定到左值，这样就避免了拷贝
    2. 容器插入与 emplace
    std::vector<std::string> vec;
    std::string s = "hello";
    vec.push_back(s);//拷贝构造
    vec.push_back(std::move(s));//移动构造，与vec.emplace_back(s)是等价的
    前者是将s拷贝一份并尾插到了s后，后者是直接在vec原地将s尾插，避免了中间的拷贝，也就是说，在尾插元素是内置类型的情况下，push_back与emplace_back在性能方面几乎没有差别，但在自定义类型的情况下，emplace_back性能是要强于push_back的
    






