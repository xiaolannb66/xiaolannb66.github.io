一、引言
  在很多时候，我们都需要用一个即将消亡的对象去构造一个新对象，在C++11之前，我们需要对这个对象进行一次拷贝，完了之后还要对该对象进行析构，对于一些数据量小的对象可能还好，但是如果在一些需要频繁构造或者在一次性构造大规模的对象时，其性能问题是十分突出的，其中包括调用成本和空间成本等等，这时就能想到让新对象直接接管将亡对象的资源，从而避免了拷贝，也就是说直接拷贝指针，然后将原对象释放并置空即可，这样就避免了一次昂贵的拷贝构造，当然这种做法在C++11之前也是可以实现的，但其可读性十分差，例如string s1(s2);你无法区分它到底是要拷贝构造+运算符赋值还是内存接管，只能靠约定，为了更直观准确的实现这一语法，C++11特意推出了move函数

二、值类别回顾
  1.左值与右值
    左值：必须命名，可以取地址
    右值：没有名字，将亡值/临时对象，常量，不能被取地址
  左值和右值最大的区别就在于能不能取地址，右值是无法被显示定义出来的，要么就对左值一定的进行操作之后的结果为右值，要么就单纯是1,2,3,4,5这样的常量
  2.右值引用
    int&& x = 10;
    所谓左值引用是左值的别名，那么右值引用就自然而然是右值的别名了，注意：x在此处是一个左值，但其在这里表示的是右值的别名，当然这行代码在实际开发中并无任何意义，我们也不会去写，只是让大家复习一下

三、什么是 std::move？    
  1.表面含义 vs 实际含义
    很多人从字面上理解，move，移动嘛，就是直接移动原对象到要新对象上嘛，但当你思考发现，要怎么移动呢，原理是什么，式子怎么写呢，你就会发现，实际上不是这样的
    它只做了一件事，将左值对象强制变为右值，如:
    string s;
    std::move(s);//等价于static_cast<string&&>(s);
    这里的move(s)后的临时对象就是右值，请注意，它不会改变s本身的属性，其仍是左值
  2.std::move 的定义（简化）
    template <typename T>
    constexpr typename std::remove_reference<T>::type&&
    move(T&& t) noexcept;
    它底层实际上就仅仅是将其转化为右值然后返回

四、移动语义的底层原理
  1. 拷贝构造 vs 移动构造
    class Buffer {
public:
    Buffer(const Buffer& other);      // 拷贝构造
    Buffer(Buffer&& other) noexcept;  // 移动构造
};
    拷贝构造是将原对象以左值引用的形式传进去的，然后拷贝一个一模一样的对象进行返回，这样就有一次拷贝的消耗
    移动构造是将原对象以右值引用的形式传进去的，然后将资源所有权转移给新对象(即拷贝原对象资源的指针),然后将原对象置空(保证了新对象资源的安全性)，这样将拷贝资源的代价转化为了拷贝指针的代价
  2. 一个最小可运行示例
class MyString {
    char* data;
public:
    MyString(MyString&& other) noexcept {
        data = other.data;
        other.data = nullptr;
    }
};
    在这里你需要注意的一点是，原对象资源只是被"偷走了",但其本身还是可以被继续操作的，只是与实际业务的其他资源/变量没有关联了，也就是说原对象也就失去了实际意义

五、std::move 的典型使用场景
  1. 函数返回值优化
    std::vector<int> foo() 
    {
      std::vector<int> v = {1, 2, 3};
      return v; 
    }
    这里你可能会认为会返回v对象的拷贝，实际上编译器对其做了优化，实际上返回的是move(v),然后调用移动构造绑定到左值，这样就避免了拷贝
  2. 容器插入与 emplace
    std::vector<std::string> vec;
    std::string s = "hello";
    vec.push_back(s);//拷贝构造
    vec.push_back(std::move(s));//移动构造，与vec.emplace_back(s)是等价的
    前者是将s拷贝一份并尾插到了s后，后者是直接在vec原地将s尾插，避免了中间的拷贝，也就是说，在尾插元素是内置类型的情况下，push_back与emplace_back在性能方面几乎没有差别，但在自定义类型的情况下，emplace_back性能是要强于push_back的
  3. 资源转移（RAII 场景）
    std::unique_ptr<int> p1 = std::make_unique<int>(10);
    std::unique_ptr<int> p2 = std::move(p1);
    乍一看你可能会很难理解，unique_ptr不是禁止拷贝吗？实际上它确实是有一个“短暂窗口”会同时指向同一份资源，只不过在移动构造时被处理掉了（即将p1置空），最终效果还是没有破坏unique_ptr的定义

六、万能引用、完美转发与 move 的关系
  1. 万能引用
    template <typename T>
    void func(T&& arg);
  这种设计十分巧妙，如果我传递的是T&/T,编译器会自动识别为void func(T& arg);
  但我如果传递的是T&&,则会识别为void func(T&& arg)
  2. 为什么不能直接 std::move？
    template <typename T>
    void wrapper(T&& arg) {
    foo(std::move(arg)); // ❌ 强制右值
  }
  乍一看可能没什么错误，但我们可以设想一种调用情况
  std::string s = "hello";
  wrapper(s);
  这里就会出现一个问题，你将s给move掉了，这里主要问题是你看似传的是s的形参，但在wrapper函数中，它会识别你传的变量是左值引用，即T&，然后在将其强制转为右值，于是便造成了这一问题
  正确方式则为：
    template <typename T>
    void wrapper(T&& arg) {
    foo(std::forward<T>(arg)); 
  }
  这里forward就叫做完美转发，它将arg的左右值属性保留了下来，在这里我们arg是左值，那么传进去的类型也就自然是左值了，之后的foo函数的一些拷贝操作也就不会影响s的成员变量了

七、常见误区
  1.对仍需使用的对象调用 std::move
    这个也很好理解，你将原对象move之后，内部的资源会改变（一般是清空）
  2.在 return 语句中滥用 std::move
    其实这个并不是禁止，而是没必要，让我们看一组简单的示例:
  template<class T>
  T f() {
      T x;
      return x;
  }
  这个我上面也讲过了，但是有一些底层细节需要澄清一下
  C++11之后会做一种优化，叫做NRVO（命名返回值优化），这个优化的规定是这样的:当你返回一个局部变量时，编译器会直接用x去构造新对象的，这个操作是零成本的，没有任何消耗
  但这并不是每次都能成功的，当NRVO失败时，编译器才会自动调用移动构造，即return move(x)
  但如果你显示写return move(x)的话，你就显示指定必须有移动构造，此时编译器不会调用NRVO,只会调用移动构造，虽然移动构造成本低，但性能仍不如NRVO，这常常被视为一种性能的退化，所以没有必要去显示调用，这种事情就交给编译器自己去处理就好了
  3.对 const 对象使用 std::move
    举个例子:
  const std::string s = "abc";
  auto x = std::move(s); 
  这个操作是否有可能编译错误呢？这就在于你移动构造函数的设计了，我相信大多数设计都诸如T(T&&),而不是T(const T&&),因为移动构造通常都要修改原对象

八、总结
  通过本文相信你也了解了move的底层原理和用法，下面让我们总结一下，首先std::move的本质是类型转换，而不是移动，其次我们也了解了move的价值在于配合移动构造/赋值以拥有更佳的性能，同时也相比传统写法的语义更清晰可读，正确使用move的关键就在于理解对象move后的值类别与被move对象后的状态

  
    











