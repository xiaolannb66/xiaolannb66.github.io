一、我们为什么要关心map/set底层？
  在实际应用开发和生活使用场景中，map/set这种键值对关联式容器几乎随处可见，比较经典的例子例如根据快递单号查快递，输入法查询汉字，单词频率，各种索引结构中
都会出现它们的影子
  同样是键值对容器，为什么有map,unordered_map还有一些第三方容器呢？对于初学者来说可能并不怎么关心底层结构，但当你在实际场景中滥用这些容器并出现bug时，定位错误是十分麻烦的，常见的问题包括：明明map/set时间复杂度为O(log n)却在热路径里乱用，迭代器失效导致的诡异Bug，选错容器导致内存浪费或局部性很差等等

二、从接口看 map / set
  1、map vs set
其实两者在使用上没有什么差别
  map<Key,T>:存放键值对，Key唯一，T可根据业务更改
  set<Key>:存放单个Key
支持的操作：增加(insert)，删除(erase)，查找(find)，遍历(根据迭代器遍历即可)(注意，不支持更改！！！后面会解释原因)

  2、map/unordered_map的差别
其实最主要的差别就是map是有序的，unordered_map则无序，然后平均大多数情况下unordered_map的时间复杂度(O(1))是要小于map的(O(log(n))
  这与其底层数据结构密切相关
  map:红黑树
  unordered_map:哈希表

三、红黑树实现的 map / set
1、为什么要平衡树，而不是普通二叉搜索树？
  一般情况下来说，二叉搜索树效率确实与平衡树差不多，但某些极端场景下，二叉搜索树会退化成链表，即每次插入的元素都比上一次大或者小，因此便设计出了
一个更为稳定的数据结构，即平衡树
  常见的平衡树包括AVL树，红黑树等，本文仅讨论红黑树

2.红黑树的节点结构
  enum Color { RED, BLACK };

template <typename Key, typename Value>
struct RBNode {
    Key key;          // 键
    Value value;      // 值 （set 可以没有 value）
    Color color;      // 节点颜色：红 / 黑
    RBNode* left;     // 左子节点
    RBNode* right;    // 右子节点
    RBNode* parent;   // 父节点
};
  看到这里你可能会好奇，这不应该是map的结构吗，set呢？实际上他们两个容器共用RBTree这一个结构，只是set做了一层包装而已，这一巧妙的设计也很好的体现了面向对象的思想
它们的Key值可以是任意类型，编译器会自动按字典序比较大小

3.红黑树的 5 条性质
  每个节点非红即黑
  根节点为黑色
  红节点的儿子节点必须为黑
  所有叶子节点(外部NIL节点，非实际插入的节点)都必须为黑色
  任意节点到所有叶子路径上的黑节点数相同

  可能很多读者会对第四条感到困惑，什么是外部NIL节点，这么设计主要是为了统一边界控制，增加代码简洁性，否则将会使得插入/删除逻辑出现"特例"，比如在插入时要经常判断"叔父"节点的颜色，如果没有这个NIL节点，将会多出来很多对根节点单独设计出来的逻辑，使得代码非常臃肿

4.它是如何保证时间复杂度趋于稳定的？
  其最重要的两个特性是第三点和第五点，这两点使得一条路径上的最少节点数与最多节点数最多构成两倍的关系，也就是说最坏也坏不到哪去，平均时间复杂度和AVL树差不了多少，都是log(N),但其相比于AVL树的优势就在于AVL树维持平衡全靠旋转，对于树的高度控制过于严格，但红黑树则是旋转+变色，这一改动使其调用开销相较反而更小

5.插入操作在底层发生了什么？
  首先我们要搞清楚，红黑插入的默认节点必须为红色，因为可以围绕上述五点性质去变色和旋转来维持其平衡性质，要是默认插入黑色节点，那它将无法维持黑高平衡
  其次在理解这部分之前，你只需要搞清楚，红黑树是以变色为主，旋转为辅，也就是说，能变色解决“黑高平衡”问题就变色，不能的话就先旋转再变色
这里就要分三类情况来说了

第一类:父红，叔叔红
        G(B)
       /    \
   P(R)    U(R)
   /
 N(R)  <--新插入节点
这种情况很明显可以通过变色去解决，将爷爷节点变为黑色，将父亲节点和叔叔节点染黑即可
        G(R)
       /    \
   P(B)    U(B)
   /
 N(R)  <--新插入节点
这样就平衡了

第二类:父红，叔叔黑
        G(B)
       /    \
   P(R)    U(B)
   /
 N(R)  <--新插入节点
这种情况，你会发现单单通过变色已经无法维持除了图示子树及以外所有节点黑高平衡了，这时只能结合旋转来解决了
我们注意到主要是要解决红红节点连起来的问题，那么我们可以先将其向右旋转，旋转完之后是这样的
        P(R)
       /    \
   N(R)     G(B)
             \
              U(B)
这时就好办了，将P节点染黑，再将G节点变为红色即可
        P(B)
       /    \
   N(R)     G(R)
             \
              U(B)
这不，平衡了

第三类:左，右冲突+第二类
  这一类的名字可能看起来比较奇怪，下面让我们看看它长啥样
               G(B)
             /      \
         P(R)        U(B)
           \
            N(R)  <--新插入节点
这种情况，你会发现和第二类很像，但新插入节点为右节点，这种情况想直接旋转G是不行的，我们得先旋转P，这样就变成了
              G(B)
             /     \
          N(R)      U(B)
          /
       P(R)
这样就又变成类型二了，再进行一次同类型二的旋转变色即可

这就是红黑树旋转变色逻辑的基本情况了，其他情况也都是我上述旋转变色的镜像而已，反着来即可

6.红黑树实现对 map/set 行为的影响
  最显而易见的一点就是这俩容器遍历出来都是有序的，因为红黑树本就基于搜索出拓展出来的，中序遍历出来自然就是有序的
  同时我们不难想到lower_bound / upper_bound这俩算法的使用十分的丝滑，正好与搜索树的性质相对应
  第三点也是十分重要的一点，就是map/set在删除元素时不会造成迭代器失效，这也十分好理解，因为他是非线性结构，只会使被删除位置的迭代器失效，而不会影响其他元素

四、使用map/set时需要注意的点
  map/set虽然遍历效率高，但是它们在某些情况并不适用

1.在热循环里频繁构造key
  举个很简单的例子，这里有两个字符串string s1="abcdefg",string s2="abcdefgh"，map/set在将s1,s2作为key并对它们进行比较时，效率很慢，有些人可能觉得没啥啊，不就俩字符串吗？实际开发中比较的字符串/结构远远比这俩字符串复杂的多，在大量且复杂的元素中这样不断对各个字典序进行比较，成本将非常高
  同时还有个非常重要的原因，正因红黑树的时间复杂度为logn,当插入大量元素时，其值将越来越趋近于1，到后面就每插入一个元素，时间就会增加一倍，这是十分可怕的
 
2.注意迭代器失效规则
  当你erase(it)时，这个it会失效，但其他节点的迭代器没事
  当你insert元素时，不会对原来所有迭代器造成影响

五、总结
  通过本文的分析相信你也了解了map/set是基于红黑树设计的两个键值对关联式容器，它底层红黑树的数据结构也直接决定了它们的时间复杂度，遍历顺序，迭代器的失效规则，内存占用和局限性，如果大家对其底层的各种细节十分好奇的话，我推荐候捷老师翻译的STL源码剖析这本书，相信我上文的总结能让你对容器的选择有更清晰的认识，并能够合理按需选择



